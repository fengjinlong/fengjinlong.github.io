(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{161:function(e,t,a){"use strict";a.r(t);var r=a(0),n=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"decorators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decorators","aria-hidden":"true"}},[e._v("#")]),e._v(" Decorators")]),e._v(" "),a("blockquote",[a("p",[e._v("Decorators 是ES7中添加的JavaScript新特性")])]),e._v(" "),a("blockquote",[a("p",[e._v("装饰器接收一个参数，也就是我们被装饰的目标方法，处理完扩展的内容后再返回一个方法，供以后调用，同时也失去了对原方法对象的访问。\n装饰器和被装饰者之间通过 @ 符进行连接。\n在JavaScript层面我们已经感性的认识了装饰器，\b我们的代码装饰的是一个函数。在JavaScript中，一共有4\b类装饰器：")])]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("Method Decorator  函数装饰器")]),e._v(" "),a("li",[e._v("Property Decorators 熟悉装饰器")]),e._v(" "),a("li",[e._v("Class Decorator 类装饰器")]),e._v(" "),a("li",[e._v("Parameter Decorator 参数装饰器")])])]),e._v(" "),a("h2",{attrs:{id:"函数装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数装饰器","aria-hidden":"true"}},[e._v("#")]),e._v(" 函数装饰器")]),e._v(" "),a("blockquote",[a("blockquote",[a("p",[e._v("通过使用 函数装饰器，我们可以控制函数的输入和输出。")])])]),e._v(" "),a("blockquote",[a("blockquote",[a("p",[e._v("下面是函数装饰器的定义：")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("MethodDecorator = <T>(target: Object, key: string, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | Void;\ntarget -> \b被装饰的对象\nkey -> 被装饰的函数名\ndescriptor -> 被传递过来的属性的属性描述符. 可以通过 Object.getOwnPropertyDescriptor()方法来查看属性描述符。\n")])])]),a("blockquote",[a("p",[e._v("Object.getOwnPropertyDescriptor()获取\b每个属性的描述符并打印出来。下面我们对value , enumerable , configurable 和 writable 做简要的说明。")])]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("value – >字面值或者函数/属性计算后的返回值。")]),e._v(" "),a("li",[e._v("enumerable -> 是否可以被枚举 (是否可以在 (for x in obj)循环中被枚举\b出来)")]),e._v(" "),a("li",[e._v("configurable – >属性是否可以被配置")]),e._v(" "),a("li",[e._v("writable -> \b属性是否是可写的.")])])]),e._v(" "),a("blockquote",[a("p",[e._v("每个属性或者方法都有自己的一个描述符，通过描述符我们可以修改属性的行为或者返回值。下面关键来了：\n"),a("strong",[e._v("装饰器的本质就是修改描述符")])])]),e._v(" "),a("h2",{attrs:{id:"方法装饰器实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法装饰器实例","aria-hidden":"true"}},[e._v("#")]),e._v(" 方法装饰器实例")]),e._v(" "),a("blockquote",[a("p",[e._v("下面我们通过方法装饰器来修改一个函数的输入和输出")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function leDecorator(target, propertyKey: string, descriptor: PropertyDescriptor): any {\n    var oldValue = descriptor.value;\n\n    descriptor.value = function() {\n      console.log(`Calling "${propertyKey}" with`, arguments,target);\n      // Executing the original function interchanging the arguments\n      let value = oldValue.apply(null, [arguments[1], arguments[0]]);\n      //returning a modified value\n      return value + "; This is awesome";\n    };\n\n    return descriptor;\n  }\n\n  class JSMeetup {\n    speaker = "Ruban";\n    //@leDecorator\n    welcome(arg1, arg2) {\n      console.log(`Arguments Received are ${arg1}, ${arg2}`);\n      return `${arg1} ${arg2}`;\n    }\n  }\n\n  const meetup = new JSMeetup();\n\n  console.log(meetup.welcome("World", "Hello"));\n')])])]),a("blockquote",[a("p",[e._v("在不使用装饰器的时候，输出值为：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Arguments Received are World, Hello\nWorld Hello\n")])])]),a("blockquote",[a("p",[e._v("启用装饰器后，输出值为：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Calling \"welcome\" with { '0': 'World', '1': 'Hello' } JSMeetup {}\nArguments Received are Hello, World\nHello World; This is awesome\n")])])]),a("blockquote",[a("p",[e._v("在新的函数中首先调用了原函数，获得了返回值，然后修改了返回值。 最后return descriptor，新的descriptor会被应用到welcome方法上，此时整合函数体已经被替换了。\n通过使用装饰器，我们实现了对原函数的包装，可以修改方法的输入和输出，这意味着我们可以应用各种想要的魔法效果到目标方法上。")])]),e._v(" "),a("blockquote",[a("p",[e._v("这里有几点需要注意的地方：")])]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("装饰器在class被声明的时候被执行，而不是class实例化的时候。")]),e._v(" "),a("li",[e._v("方法装饰器返回一个值")]),e._v(" "),a("li",[e._v("存储原有的描述符并且返回一个新的描述符是我们推荐的做法. 这在多描述符应用的场景下非常有用。")]),e._v(" "),a("li",[e._v("设置描述符的value的时候，不要使用箭头函数。")])])]),e._v(" "),a("h2",{attrs:{id:"属性装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性装饰器","aria-hidden":"true"}},[e._v("#")]),e._v(" 属性装饰器")]),e._v(" "),a("blockquote",[a("p",[e._v("属性装饰器和方法装饰器很类似，通过属性装饰器，我们可以用来重新定义getters、setters，修改enumerable, configurable等属性。\n属性装饰器定义如下：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("PropertyDecorator = (target: Object, key: string) => void;\n\ntarget：属性拥有者\nkey：属性名\n")])])]),a("blockquote",[a("p",[e._v("Object.defineProperty方法通常用来动态给一个对象\b添加或者修改属性。下面是一段示例：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var o = { get foo() { return 17; }, bar:17, foobar:function(){return \"FooBar\"} };\n\nObject.defineProperty(o, 'myProperty', {\nget: function () {\nreturn this['myProperty'];\n},\nset: function (val) {\nthis['myProperty'] = val;\n},\nenumerable:true,\nconfigurable:true\n});\n")])])]),a("blockquote",[a("p",[e._v("从结果中，我们看到，利用Object.defineProperty，我们动态添给对象添加了属性。下面我们基于Object.defineProperty来实现一个简单的属性装饰器。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function realName(target, key: string): any {\n    // property value\n    var _val = target[key];\n\n    // property getter\n    var getter = function () {\n      return "Ragularuban(" + _val + ")";\n    };\n\n    // property setter\n    var setter = function (newVal) {\n      _val = newVal;\n    };\n\n    // Create new property with getter and setter\n    Object.defineProperty(target, key, {\n      get: getter,\n      set: setter\n    });\n  }\n\n  class JSMeetup {\n    //@realName\n    public myName = "Ruban";\n    constructor() {\n    }\n    greet() {\n      return "Hi, I\'m " + this.myName;\n    }\n  }\n\n  const meetup = new JSMeetup();\n  console.log(meetup.greet());\n  meetup.myName = "Ragul";\n  console.log(meetup.greet());\n')])])]),a("h2",{attrs:{id:"class-装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-装饰器","aria-hidden":"true"}},[e._v("#")]),e._v(" Class 装饰器")]),e._v(" "),a("blockquote",[a("p",[e._v("Class装饰器是通过操作Class的构造函数，来实现对Class的相关属性和方法的动态添加和修改。\n下面是Class装饰器的定义：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction;\n")])])]),a("blockquote",[a("p",[e._v("ClassDecorator只接收一个参数，就是Class的构造函数。下面的示例代码，修改了类原有的属性speaker，并动态添加了一个属性extra。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function AwesomeMeetup<T extends { new (...args: any[]): {} }>(constructor: T) {\n    return class extends constructor implements extra {\n      speaker: string = "Ragularuban";\n      extra = "Tadah!";\n    }\n  }\n\n  //@AwesomeMeetup\n  class JSMeetup {\n    public speaker = "Ruban";\n    constructor() {\n    }\n    greet() {\n      return "Hi, I\'m " + this.speaker;\n    }\n  }\n\n  interface extra {\n    extra: string;\n  }\n\n  const meetup = new JSMeetup() as JSMeetup & extra;\n  console.log(meetup.greet());\n  console.log(meetup.extra);\n\nI m Ruban\nundefined\n\nI m Ragularban\nTadah!\n')])])]),a("blockquote",[a("p",[e._v("这里需要注意的是，"),a("strong",[e._v("构造函数只会被调用一次")])])]),e._v(" "),a("h2",{attrs:{id:"参数装饰器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数装饰器","aria-hidden":"true"}},[e._v("#")]),e._v(" 参数装饰器")]),e._v(" "),a("blockquote",[a("p",[e._v("如果通过上面讲过的装饰器来推论参数装饰器的作用，可能会是修改参数，但事实上并非如此。参数装饰器往往用来对特殊的参数进行标记，然后在方法装饰器中读取对应的标记，执行进一步的操作。例如：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('function logParameter(target: any, key: string, index: number) {\n    var metadataKey = `myMetaData`;\n    if (Array.isArray(target[metadataKey])) {\n      target[metadataKey].push(index);\n    }\n    else {\n      target[metadataKey] = [index];\n    }\n  }\n\n  function logMethod(target, key: string, descriptor: any): any {\n    var originalMethod = descriptor.value;\n    descriptor.value = function (...args: any[]) {\n\n      var metadataKey = `myMetaData`;\n      var indices = target[metadataKey];\n      console.log(\'indices\', indices);\n      for (var i = 0; i < args.length; i++) {\n\n        if (indices.indexOf(i) !== -1) {\n          console.log("Found a marked parameter at index" + i);\n          args[i] = "Abrakadabra";\n        }\n      }\n      var result = originalMethod.apply(this, args);\n      return result;\n\n    }\n    return descriptor;\n  }\n\n  class JSMeetup {\n    //@logMethod\n    public saySomething(something: string, @logParameter somethingElse: string): string {\n      return something + " : " + somethingElse;\n    }\n  }\n\n  let meetup = new JSMeetup();\n\n  console.log(meetup.saySomething("something", "Something Else"));\n\n\n')])])]),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),a("blockquote",[a("p",[e._v("现在我们已经学习了所有装饰器的使用，下面\b总结一下关键用法：")])]),e._v(" "),a("blockquote",[a("p",[e._v("方法装饰器的核心是 方法描述符")])]),e._v(" "),a("blockquote",[a("blockquote",[a("p",[e._v("Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）")])])]),e._v(" "),a("blockquote",[a("p",[e._v("属性装饰器的核心是 Object.defineProperty")])]),e._v(" "),a("blockquote",[a("p",[e._v("Class装饰器的核心是 构造函数")])]),e._v(" "),a("blockquote",[a("p",[e._v("参数装饰器的主要作用是标记，要结合方法装饰器来使用")])]),e._v(" "),a("blockquote",[a("p",[e._v("https://juejin.im/post/5ac85f1d6fb9a028bf0590ee#heading-0")])])])},[],!1,null,null,null);t.default=n.exports}}]);