(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{159:function(e,n,t){"use strict";t.r(n);var s=t(0),r=Object(s.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"手写思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手写思路","aria-hidden":"true"}},[e._v("#")]),e._v(" 手写思路")]),e._v(" "),t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/6/26/1643b4974e9b815b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",width:"100%"}}),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("1 Promise 的声明")]),e._v(" "),t("li",[e._v("2 解决基本状态")]),e._v(" "),t("li",[e._v("3 then")]),e._v(" "),t("li",[e._v("4 解决异步实现 setTomeout")]),e._v(" "),t("li",[e._v("5 解决链式调用")]),e._v(" "),t("li",[e._v("6 完成resolvePromise函数")]),e._v(" "),t("li",[e._v("7 解决其他问题")]),e._v(" "),t("li",[e._v("8 catch resolve reject race all")])])]),e._v(" "),t("h2",{attrs:{id:"_1-promise-的声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-promise-的声明","aria-hidden":"true"}},[e._v("#")]),e._v(" 1 Promise 的声明")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  // 构造器\n  constructor(executor){\n    // 成功\n    let resolve = () => { };\n    // 失败\n    let reject = () => { };\n    // 立即执行\n    executor(resolve, reject);\n  }\n}\n\n")])])]),t("h2",{attrs:{id:"_2-解决基本状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决基本状态","aria-hidden":"true"}},[e._v("#")]),e._v(" 2 解决基本状态")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  constructor(executor){\n    // 初始化state为等待态\n    this.state = 'pending';\n    // 成功的值\n    this.value = undefined;\n    // 失败的原因\n    this.reason = undefined;\n    let resolve = value => {\n      // state改变,resolve调用就会失败\n      if (this.state === 'pending') {\n        // resolve调用后，state转化为成功态\n        this.state = 'fulfilled';\n        // 储存成功的值\n        this.value = value;\n      }\n    };\n    let reject = reason => {\n      // state改变,reject调用就会失败\n      if (this.state === 'pending') {\n        // reject调用后，state转化为失败态\n        this.state = 'rejected';\n        // 储存失败的原因\n        this.reason = reason;\n      }\n    };\n    // 如果executor执行报错，直接执行reject\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n}\n\n\n")])])]),t("h2",{attrs:{id:"_3-then"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-then","aria-hidden":"true"}},[e._v("#")]),e._v(" 3 then")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  constructor(executor){...}\n  // then 方法 有两个参数onFulfilled onRejected\n  then(onFulfilled,onRejected) {\n    // 状态为fulfilled，执行onFulfilled，传入成功的值\n    if (this.state === 'fulfilled') {\n      onFulfilled(this.value);\n    };\n    // 状态为rejected，执行onRejected，传入失败的原因\n    if (this.state === 'rejected') {\n      onRejected(this.reason);\n    };\n  }\n}\n\n")])])]),t("h2",{attrs:{id:"_4-解决异步实现-settomeout"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-解决异步实现-settomeout","aria-hidden":"true"}},[e._v("#")]),e._v(" 4 解决异步实现 setTomeout")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  constructor(executor){\n    this.state = 'pending';\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功存放的数组\n    this.onResolvedCallbacks = [];\n    // 失败存放法数组\n    this.onRejectedCallbacks = [];\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        // 一旦resolve执行，调用成功数组的函数\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    };\n    let reject = reason => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        // 一旦reject执行，调用失败数组的函数\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    };\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n  then(onFulfilled,onRejected) {\n    if (this.state === 'fulfilled') {\n      onFulfilled(this.value);\n    };\n    if (this.state === 'rejected') {\n      onRejected(this.reason);\n    };\n    // 当状态state为pending时\n    if (this.state === 'pending') {\n      // onFulfilled传入到成功数组\n      this.onResolvedCallbacks.push(()=>{\n        onFulfilled(this.value);\n      })\n      // onRejected传入到失败数组\n      this.onRejectedCallbacks.push(()=>{\n        onRejected(this.reason);\n      })\n    }\n  }\n}\n\n\n")])])]),t("h2",{attrs:{id:"_5-解决链式调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-解决链式调用","aria-hidden":"true"}},[e._v("#")]),e._v(" 5 解决链式调用")]),e._v(" "),t("blockquote",[t("p",[e._v("1、为了达成链式，我们默认在第一个then里返回一个promise。秘籍规定了一种方法，就是在then里面返回一个新的promise,称为promise2：promise2 = new Promise((resolve, reject)=>{})")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("将这个promise2返回的值传递到下一个then中")]),e._v(" "),t("li",[e._v("如果返回一个普通的值，则将普通的值传递给下一个then中")])])]),e._v(" "),t("blockquote",[t("p",[e._v("2、当我们在第一个then中return了一个参数（参数未知，需判断）。这个return出来的新的promise就是onFulfilled()或onRejected()的值")])]),e._v(" "),t("blockquote",[t("p",[e._v("秘籍则规定onFulfilled()或onRejected()的值，即第一个then返回的值，叫做x，判断x的函数叫做resolvePromise")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("首先，要看x是不是promise。")]),e._v(" "),t("li",[e._v("如果是promise，则取它的结果，作为新的promise2成功的结果")]),e._v(" "),t("li",[e._v("如果是普通值，直接作为promise2成功的结果")]),e._v(" "),t("li",[e._v("所以要比较x和promise2")]),e._v(" "),t("li",[e._v("resolvePromise的参数有promise2（默认返回的promise）、x（我们自己return的对象）、resolve、reject")]),e._v(" "),t("li",[e._v("resolve和reject是promise2的")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  constructor(executor){\n    this.state = 'pending';\n    this.value = undefined;\n    this.reason = undefined;\n    this.onResolvedCallbacks = [];\n    this.onRejectedCallbacks = [];\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    };\n    let reject = reason => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    };\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n  then(onFulfilled,onRejected) {\n    // 声明返回的promise2\n    let promise2 = new Promise((resolve, reject)=>{\n      if (this.state === 'fulfilled') {\n        let x = onFulfilled(this.value);\n        // resolvePromise函数，处理自己return的promise和默认的promise2的关系\n        resolvePromise(promise2, x, resolve, reject);\n      };\n      if (this.state === 'rejected') {\n        let x = onRejected(this.reason);\n        resolvePromise(promise2, x, resolve, reject);\n      };\n      if (this.state === 'pending') {\n        this.onResolvedCallbacks.push(()=>{\n          let x = onFulfilled(this.value);\n          resolvePromise(promise2, x, resolve, reject);\n        })\n        this.onRejectedCallbacks.push(()=>{\n          let x = onRejected(this.reason);\n          resolvePromise(promise2, x, resolve, reject);\n        })\n      }\n    });\n    // 返回promise，完成链式\n    return promise2;\n  }\n}\n\n\n")])])]),t("h2",{attrs:{id:"_6-完成resolvepromise函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-完成resolvepromise函数","aria-hidden":"true"}},[e._v("#")]),e._v(" 6 完成resolvePromise函数")]),e._v(" "),t("blockquote",[t("p",[e._v("秘籍规定了一段代码，让不同的promise代码互相套用，叫做resolvePromise")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("如果 x === promise2，则是会造成循环引用，自己等待自己完成，则报“循环引用”错误")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let p = new Promise(resolve => {\n  resolve(0);\n});\nvar p2 = p.then(data => {\n  // 循环引用，自己等待自己完成，一辈子完不成\n  return p2;\n})\n\n")])])]),t("blockquote",[t("p",[e._v("1、判断x")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("Otherwise, if x is an object or function,Let then be x.then")]),e._v(" "),t("li",[e._v("x 不能是null")]),e._v(" "),t("li",[e._v("x 是普通值 直接resolve(x)")]),e._v(" "),t("li",[e._v("x 是对象或者函数（包括promise），let then = x.then")])])]),e._v(" "),t("blockquote",[t("p",[e._v("2、当x是对象或者函数（默认promise）")]),e._v(" "),t("ul",[t("li",[e._v("声明了then")]),e._v(" "),t("li",[e._v("如果取then报错，则走reject()")]),e._v(" "),t("li",[e._v("如果then是个函数，则用call执行then，第一个参数是this，后面是成功的回调和失败的回调")]),e._v(" "),t("li",[e._v("如果成功的回调还是pormise，就递归继续解析")])])]),e._v(" "),t("blockquote",[t("p",[e._v("3、成功和失败只能调用一个 所以设定一个called来防止多次调用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function resolvePromise(promise2, x, resolve, reject){\n  // 循环引用报错\n  if(x === promise2){\n    // reject报错\n    return reject(new TypeError('Chaining cycle detected for promise'));\n  }\n  // 防止多次调用\n  let called;\n  // x不是null 且x是对象或者函数\n  if (x != null && (typeof x === 'object' || typeof x === 'function')) {\n    try {\n      // A+规定，声明then = x的then方法\n      let then = x.then;\n      // 如果then是函数，就默认是promise了\n      if (typeof then === 'function') { \n        // 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调\n        then.call(x, y => {\n          // 成功和失败只能调用一个\n          if (called) return;\n          called = true;\n          // resolve的结果依旧是promise 那就继续解析\n          resolvePromise(promise2, y, resolve, reject);\n        }, err => {\n          // 成功和失败只能调用一个\n          if (called) return;\n          called = true;\n          reject(err);// 失败了就失败了\n        })\n      } else {\n        resolve(x); // 直接成功即可\n      }\n    } catch (e) {\n      // 也属于失败\n      if (called) return;\n      called = true;\n      // 取then出错了那就不要在继续执行了\n      reject(e); \n    }\n  } else {\n    resolve(x);\n  }\n}\n\n")])])]),t("h2",{attrs:{id:"_7-解决其他问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-解决其他问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 7 解决其他问题")]),e._v(" "),t("blockquote",[t("p",[e._v("1、秘籍规定onFulfilled,onRejected都是可选参数，如果他们不是函数，必须被忽略")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("onFulfilled返回一个普通的值，成功时直接等于 value => value")]),e._v(" "),t("li",[e._v("onRejected返回一个普通的值，失败时如果直接等于 value => value，则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误reason => throw err\n2、秘籍规定onFulfilled或onRejected不能同步被调用，必须异步调用。我们就用setTimeout解决异步问题")]),e._v(" "),t("li",[e._v("如果onFulfilled或onRejected报错，则直接返回reject()")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  constructor(executor){\n    this.state = 'pending';\n    this.value = undefined;\n    this.reason = undefined;\n    this.onResolvedCallbacks = [];\n    this.onRejectedCallbacks = [];\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    };\n    let reject = reason => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    };\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n  then(onFulfilled,onRejected) {\n    // onFulfilled如果不是函数，就忽略onFulfilled，直接返回value\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    // onRejected如果不是函数，就忽略onRejected，直接扔出错误\n    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };\n    let promise2 = new Promise((resolve, reject) => {\n      if (this.state === 'fulfilled') {\n        // 异步\n        setTimeout(() => {\n          try {\n            let x = onFulfilled(this.value);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      };\n      if (this.state === 'rejected') {\n        // 异步\n        setTimeout(() => {\n          // 如果报错\n          try {\n            let x = onRejected(this.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      };\n      if (this.state === 'pending') {\n        this.onResolvedCallbacks.push(() => {\n          // 异步\n          setTimeout(() => {\n            try {\n              let x = onFulfilled(this.value);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0);\n        });\n        this.onRejectedCallbacks.push(() => {\n          // 异步\n          setTimeout(() => {\n            try {\n              let x = onRejected(this.reason);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0)\n        });\n      };\n    });\n    // 返回promise，完成链式\n    return promise2;\n  }\n}\n\n\n")])])]),t("h2",{attrs:{id:"_7-catch-resolve-reject-race-all"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-catch-resolve-reject-race-all","aria-hidden":"true"}},[e._v("#")]),e._v(" 7 catch?resolve?reject?race?all??")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise{\n  constructor(executor){\n    this.state = 'pending';\n    this.value = undefined;\n    this.reason = undefined;\n    this.onResolvedCallbacks = [];\n    this.onRejectedCallbacks = [];\n    let resolve = value => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    };\n    let reject = reason => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    };\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n  then(onFulfilled,onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };\n    let promise2 = new Promise((resolve, reject) => {\n      if (this.state === 'fulfilled') {\n        setTimeout(() => {\n          try {\n            let x = onFulfilled(this.value);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      };\n      if (this.state === 'rejected') {\n        setTimeout(() => {\n          try {\n            let x = onRejected(this.reason);\n            resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      };\n      if (this.state === 'pending') {\n        this.onResolvedCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              let x = onFulfilled(this.value);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0);\n        });\n        this.onRejectedCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              let x = onRejected(this.reason);\n              resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0)\n        });\n      };\n    });\n    return promise2;\n  }\n  catch(fn){\n    return this.then(null,fn);\n  }\n}\nfunction resolvePromise(promise2, x, resolve, reject){\n  if(x === promise2){\n    return reject(new TypeError('Chaining cycle detected for promise'));\n  }\n  let called;\n  if (x != null && (typeof x === 'object' || typeof x === 'function')) {\n    try {\n      let then = x.then;\n      if (typeof then === 'function') { \n        then.call(x, y => {\n          if(called)return;\n          called = true;\n          resolvePromise(promise2, y, resolve, reject);\n        }, err => {\n          if(called)return;\n          called = true;\n          reject(err);\n        })\n      } else {\n        resolve(x);\n      }\n    } catch (e) {\n      if(called)return;\n      called = true;\n      reject(e); \n    }\n  } else {\n    resolve(x);\n  }\n}\n//resolve方法\nPromise.resolve = function(val){\n  return new Promise((resolve,reject)=>{\n    resolve(val)\n  });\n}\n//reject方法\nPromise.reject = function(val){\n  return new Promise((resolve,reject)=>{\n    reject(val)\n  });\n}\n//race方法 \nPromise.race = function(promises){\n  return new Promise((resolve,reject)=>{\n    for(let i=0;i<promises.length;i++){\n      promises[i].then(resolve,reject)\n    };\n  })\n}\n//all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)\nPromise.all = function(promises){\n  let arr = [];\n  let i = 0;\n  function processData(index,data){\n    arr[index] = data;\n    i++;\n    if(i == promises.length){\n      resolve(arr);\n    };\n  };\n  return new Promise((resolve,reject)=>{\n    for(let i=0;i<promises.length;i++){\n      promises[i].then(data=>{\n        processData(i,data);\n      },reject);\n    };\n  });\n}\n\n")])])]),t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/6/27/1643f03d413c4ce8?imageslim",width:"100%"}})])},[],!1,null,null,null);n.default=r.exports}}]);