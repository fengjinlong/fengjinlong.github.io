(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{184:function(n,e,t){"use strict";t.r(e);var r=t(0),o=Object(r.a)({},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[n._v("#")]),n._v(" 深拷贝")]),n._v(" "),t("h2",{attrs:{id:"只对-一层级-做深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#只对-一层级-做深拷贝","aria-hidden":"true"}},[n._v("#")]),n._v(" 只对 "),t("em",[n._v("一层级")]),n._v(" 做深拷贝")]),n._v(" "),t("blockquote",[t("p",[n._v("深拷贝数组")]),n._v(" "),t("ul",[t("li",[n._v("1.直接遍历")]),n._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[n._v("slice()")])])]),n._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[n._v("concat()")])])]),n._v(" "),t("li",[n._v("该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。")])])]),n._v(" "),t("blockquote",[t("p",[n._v("深拷贝对象")]),n._v(" "),t("ul",[t("li",[n._v("1 ES6的Object.assign")]),n._v(" "),t("li",[n._v("2 1.JSON.parse(JSON.stringify(XXXX))")]),n._v(" "),t("li",[n._v("3 递归")])])]),n._v(" "),t("p",[n._v("/**")]),n._v(" "),t("ul",[t("li",[n._v("1 获取类型")]),n._v(" "),t("li",[n._v("2 循环引用数组")]),n._v(" "),t("li",[n._v("3 判断5种类型（symble, array, regExp, obj, date）")]),n._v(" "),t("li",[n._v("4 循环处理")]),n._v(" "),t("li",[n._v("5 遍历\n*/")])]),n._v(" "),t("p",[n._v("/**")]),n._v(" "),t("ul",[t("li",[n._v("Symble(Symbol.keyFor(oldObj).toString())")]),n._v(" "),t("li",[n._v("new RegExp(oldObj.source, oldObj.flags)")]),n._v(" "),t("li",[n._v("if (oldObj.lastIndex) newObj.lastIndex = oldObj.lastIndex;")]),n._v(" "),t("li",[n._v("new Date(oldObj.getTime());")]),n._v(" "),t("li")]),n._v(" "),t("p",[n._v("*/")]),n._v(" "),t("h2",{attrs:{id:"对-多层级-做深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对-多层级-做深拷贝","aria-hidden":"true"}},[n._v("#")]),n._v(" 对 "),t("em",[n._v("多层级")]),n._v(" 做深拷贝")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const getType = (obj)=> {\n\tvar toString = Object.prototype.toString;\n\tvar map = {\n\t    '[object Boolean]'  : 'boolean', \n\t    '[object Number]'   : 'number', \n\t    '[object String]'   : 'string', \n\t    '[object Function]' : 'function', \n\t    '[object Array]'    : 'array', \n\t    '[object Date]'     : 'date', \n\t    '[object RegExp]'   : 'regExp', \n\t    '[object Undefined]': 'undefined',\n\t    '[object Null]'     : 'null', \n        '[object Object]'   : 'object',\n        '[object Symbol]'   : 'symbol'\n\t};\n\tif(obj instanceof Element) {//因为对不同标签，toString会返回对应不同标签的构造函数\n        return 'element';\n\t}\n\treturn map[toString.call(obj)];\n}\n// ES6 flags 代替此方法\n// const getRegExp = re => {\n//   var flags = '';\n//   if (re.global) flags += 'g';\n//   if (re.ignoreCase) flags += 'i';\n//   if (re.multiline) flags += 'm';\n//   return flags;\n// };\n\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst deepClone = oldObj => {\n  // 维护两个储存循环引用的数组\n  const oldObjArr = [];\n  const newObjArr = [];\n\n  const clone = oldObj => { \n      \n    let newObj, proto;\n\n    const type = getType(oldObj);\n\n    switch(type){\n        case 'boolean':\n        case 'number':\n        case 'string':\n        case 'null':\n        case 'undefined':\n        case 'function':{\n            return oldObj;\n            break;\n        }\n        case 'symbol':{\n            return Symbol(Symbol.keyFor(oldObj).toString());\n            break;\n        }\n        case 'array':{\n            newObj = [];\n            break;\n        }\n        case 'regExp':{\n            newObj = new RegExp(oldObj.source, oldObj.flags);\n            if (oldObj.lastIndex) newObj.lastIndex = oldObj.lastIndex;\n            break;\n        }\n        case 'date':{\n            newObj = new Date(oldObj.getTime());            \n            break;\n        }\n        //case 'obj':\n        default:{\n            // 处理对象原型\n            proto = Object.getPrototypeOf(oldObj);\n            // 利用Object.create切断原型链\n            newObj = Object.create(proto);\n            break;\n        }\n   }\n\n   // 处理循环引用\n   const index = oldObjArr.indexOf(oldObj);\n   if (index != -1) {// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象    \n     return newObjArr[index];\n   }\n\n   oldObjArr.push(oldObj);\n   newObjArr.push(newObj);\n  /*数组和对象都可以用forin语句，虽然数组使用forin会有一个问题(具体看最下面）。\n  但是这里不会影响，所以这么用 \n  */\n   for (let i in oldObj) {// 递归     \n     newObj[i] = clone(oldObj[i]);\n   }\n\n   return newObj;\n };\n\n\n return clone(oldObj);\n}\n\n/*\n测试成功\n*/\nfunction person(pname) {\n    this.name = pname;\n}\n  \nconst Messi = new person('Messi');\n  \nfunction say() {\n    console.log('hi');\n};\n  \nconst oldObj = {\n    a: say,\n    b: new Array(1),\n    c: new RegExp('ab+c', 'i'),\n    d: Messi\n  };\n  \n  const newObj = deepClone(oldObj);\n  \n  console.log(newObj.a, oldObj.a); //[Function: say] [Function: say]\n  console.log(newObj.b[0], oldObj.b[0]); // undefined undefined\n  console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\n  console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person][Function: person]\n  \n")])])]),t("blockquote",[t("p",[n._v("方法2")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const isType = (obj, type) => {\n  if (typeof obj !== 'object') return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case 'Array':\n      flag = typeString === '[object Array]';\n      break;\n    case 'Date':\n      flag = typeString === '[object Date]';\n      break;\n    case 'RegExp':\n      flag = typeString === '[object RegExp]';\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n\n/**\n* deep clone\n* @param  {[type]} parent object 需要进行克隆的对象\n* @return {[type]}        深克隆后的对象\n*/\nconst clone = parent => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = parent => {\n    if (parent === null) return null;\n    if (typeof parent !== 'object') return parent;\n\n    let child, proto;\n\n    if (isType(parent, 'Array')) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, 'RegExp')) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, parent.flags);\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, 'Date')) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};\n")])])])])},[],!1,null,null,null);e.default=o.exports}}]);