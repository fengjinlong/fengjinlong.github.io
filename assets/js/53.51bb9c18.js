(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{165:function(t,v,_){"use strict";_.r(v);var i=_(0),l=Object(i.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"html控制-html-css-hint-善用css"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#html控制-html-css-hint-善用css","aria-hidden":"true"}},[t._v("#")]),t._v(" html控制 Html Css Hint 善用css")]),t._v(" "),_("ol",[_("li",[t._v("压缩前文件110k左右，Gzip后25k 首页0.8")]),t._v(" "),_("li",[t._v("合并文件不超过5个")]),t._v(" "),_("li",[t._v("MD5")]),t._v(" "),_("li",[t._v("多个CDN Gzip")]),t._v(" "),_("li",[t._v("雅虎军规")]),t._v(" "),_("li",[t._v("离线")]),t._v(" "),_("li",[t._v("localStorage 一共5M")]),t._v(" "),_("li",[t._v("basket.js 缓存js css到本地（https://github.com/addyosmani/basket.js）")]),t._v(" "),_("li",[t._v("前端ORM存储方案 localForage")]),t._v(" "),_("li",[t._v("8 + 9 网站业务文件（静态资源）离线缓存")]),t._v(" "),_("li",[t._v("HTTP2 多路复用")])]),t._v(" "),_("h2",{attrs:{id:"多路复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用","aria-hidden":"true"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),_("ol",[_("li",[t._v("浏览器器请求//xx.cn/a.js--\x3e解析域名—>HTTP连接—>服务器器处理文件—>返回数据--\x3e浏览器解析、渲染文件。")]),t._v(" "),_("li",[t._v("Keep-Alive解决的核⼼心问 题就在此，一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复⽤用每一次建立的接通道，以达到提⾼高请求 效率的问题。一定时间是可以配置的，")]),t._v(" "),_("li",[t._v("HTTP1.1还是存在效率问题，第⼀个:串串⾏行行的⽂文件传输。第二个:连接数过多。")]),t._v(" "),_("li",[t._v("HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建⽴一路连接。同样Apache的最⼤接数为300，因为有了了 这个新特性，最⼤的并发就可以提升到300，⽐原来提升了了6倍!")])]),t._v(" "),_("h2",{attrs:{id:"为什么不要浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么不要浏览器缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么不要浏览器缓存")]),t._v(" "),_("ol",[_("li",[t._v("浏览器缓存需要网络")]),t._v(" "),_("li",[t._v("移动端极速浏览器屏蔽缓存")]),t._v(" "),_("li",[t._v("被手机管家干掉")])]),t._v(" "),_("p",[t._v("===============网站渲染==============")]),t._v(" "),_("h2",{attrs:{id:"网页渲染过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网页渲染过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 网页渲染过程")]),t._v(" "),_("ol",[_("li",[t._v("获取Dom元素并分割多个多层")]),t._v(" "),_("li",[t._v("对每个图层节点进行样式的计算 Recalculate Style")]),t._v(" "),_("li",[t._v("为每个节点生成图形和位置 Layout 重排")]),t._v(" "),_("li",[t._v("对每个节点进行绘制 填充到图层中去 Paint 重绘")]),t._v(" "),_("li",[t._v("把图层作为纹理上传GPU Composite")])]),t._v(" "),_("p",[_("em",[t._v("重排一定是引起重绘 但是重绘不一定引起重排")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[t._v("Layout 》 Paint 》  Composite Layers")])]),t._v(" "),_("li",[_("p",[t._v("网页要分层  根元素、position、transform、半透明、canvas、video、overflow")])]),t._v(" "),_("li",[_("p",[t._v("让GPU参与的分层 硬件加速 CSS3D、Video、webgl、滤镜")])]),t._v(" "),_("li",[_("p",[t._v("重排")]),t._v(" "),_("blockquote",[_("ul",[_("li",[t._v("添加或者删除dom元素")]),t._v(" "),_("li",[t._v("元素位置改变")]),t._v(" "),_("li",[t._v("盒子模型变了")]),t._v(" "),_("li",[t._v("页面初始化")]),t._v(" "),_("li",[t._v("读到某个属性 offset scroll client width")])])])]),t._v(" "),_("li",[_("p",[t._v('const h1 = document.get("xx").clientHeight;\nconst h2 = document.get("xx").offset;\nh1+h2\n读写分离\nrequestAnimationFrame -》 设置')])]),t._v(" "),_("li",[_("p",[t._v("cpu和gpu渲染的区别\n相同之处：两者都有总线的和外界联系 有自己的缓存体系 以及数字和逻辑的运算单元 为计算而生\n不同之处:CPU主要是负责操作系统相关的 GOU主要负责和显示相关 效率更高")])]),t._v(" "),_("li",[_("p",[t._v("QPS = PV/t 1000000/10"),_("em",[t._v("60")]),t._v("60=27.7 100万请求集中10小时，服务器每秒处理27.7个业务请求")])])])])},[],!1,null,null,null);v.default=l.exports}}]);