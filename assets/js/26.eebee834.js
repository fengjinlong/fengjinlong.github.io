(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{185:function(e,n,t){"use strict";t.r(n);var a=t(0),s=Object(a.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"eventbus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventbus","aria-hidden":"true"}},[e._v("#")]),e._v(" eventBus")]),e._v(" "),t("h3",{attrs:{id:"我们仿照node中event-api实现一个简单的event库-他是发布订阅模式的典型应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们仿照node中event-api实现一个简单的event库-他是发布订阅模式的典型应用","aria-hidden":"true"}},[e._v("#")]),e._v(" 我们仿照Node中Event API实现一个简单的Event库,他是发布订阅模式的典型应用.")]),e._v(" "),t("h2",{attrs:{id:"初始化class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化class","aria-hidden":"true"}},[e._v("#")]),e._v(" 初始化class")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class EventEmeitter {\n  constructor() {\n    this._events = this._events || new Map(); // 储存事件/回调键值对\n    this._maxListeners = this._maxListeners || 10; // 设立监听上限\n  }\n}\n")])])]),t("blockquote",[t("p",[e._v("监听与触发")])]),e._v(" "),t("blockquote",[t("p",[e._v("当然当Node全面拥抱ES6+之后,相应的call/apply操作用Reflect新关键字重写了,但是我们不想写的那么复杂,就做了一个简化版.")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 触发名为type的事件\nEventEmeitter.prototype.emit = function(type, ...args) {\n  let handler;\n  // 从储存事件键值对的this._events中获取对应事件回调函数\n  handler = this._events.get(type);\n  if (args.length > 0) {\n    handler.apply(this, args);\n  } else {\n    handler.call(this);\n  }\n  return true;\n};\n\n// 监听名为type的事件\nEventEmeitter.prototype.addListener = function(type, fn) {\n  // 将type事件以及对应的fn函数放入this._events中储存\n  if (!this._events.get(type)) {\n    this._events.set(type, fn);\n  }\n};\n")])])]),t("blockquote",[t("p",[e._v("我们实现了触发事件的emit方法和监听事件的addListener方法,至此我们就可以进行简单的实践了.")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 实例化\nconst emitter = new EventEmeitter();\n\n// 监听一个名为arson的事件对应一个回调函数\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\n\n// 我们触发arson事件,发现回调成功执行\nemitter.emit('arson', 'low-end'); // expel low-end\n")])])]),t("blockquote",[t("p",[e._v("似乎不错,我们实现了基本的触发/监听,但是如果有多个监听者呢?")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 重复监听同一个事件名\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\nemitter.addListener('arson', man => {\n  console.log(`save ${man}`);\n});\n\nemitter.emit('arson', 'low-end'); // expel low-end\n")])])]),t("blockquote",[t("p",[e._v("是的,只会触发第一个,因此我们需要进行改造")])]),e._v(" "),t("h2",{attrs:{id:"升级改造"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#升级改造","aria-hidden":"true"}},[e._v("#")]),e._v(" 升级改造")]),e._v(" "),t("blockquote",[t("p",[e._v("我们的addListener实现方法还不够健全,在绑定第一个监听者之后,我们就无法对后续监听者进行绑定了,因此我们需要将后续监听者与第一个监听者函数放到一个数组里.")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n// 触发名为type的事件\nEventEmeitter.prototype.emit = function(type, ...args) {\n  let handler;\n  handler = this._events.get(type);\n  if (Array.isArray(handler)) {\n    // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (args.length > 0) {\n        handler[i].apply(this, args);\n      } else {\n        handler[i].call(this);\n      }\n    }\n  } else { // 单个函数的情况我们直接触发即可\n    if (args.length > 0) {\n      handler.apply(this, args);\n    } else {\n      handler.call(this);\n    }\n  }\n\n  return true;\n};\n\n// 监听名为type的事件\nEventEmeitter.prototype.addListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n  if (!handler) {\n    this._events.set(type, fn);\n  } else if (handler && typeof handler === 'function') {\n    // 如果handler是函数说明只有一个监听者\n    this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存\n  } else {\n    handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可\n  }\n};\n")])])]),t("blockquote",[t("p",[e._v("从此以后可以愉快的触发多个监听者的函数了.")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 监听同一个事件名\nemitter.addListener('arson', man => {\n  console.log(`expel ${man}`);\n});\nemitter.addListener('arson', man => {\n  console.log(`save ${man}`);\n});\n\nemitter.addListener('arson', man => {\n  console.log(`kill ${man}`);\n});\n\n// 触发事件\nemitter.emit('arson', 'low-end');\n//expel low-end\n//save low-end\n//kill low-end\n")])])]),t("blockquote",[t("p",[e._v("移除监听")])]),e._v(" "),t("blockquote",[t("p",[e._v("我们会用removeListener函数移除监听函数,但是匿名函数是无法移除的.")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("EventEmeitter.prototype.removeListener = function(type, fn) {\n  const handler = this._events.get(type); // 获取对应事件名称的函数清单\n\n  // 如果是函数,说明只被监听了一次\n  if (handler && typeof handler === 'function') {\n    this._events.delete(type, fn);\n  } else {\n    let postion;\n    // 如果handler是数组,说明被监听多次要找到对应的函数\n    for (let i = 0; i < handler.length; i++) {\n      if (handler[i] === fn) {\n        postion = i;\n        break;\n      } else {\n        postion = -1;\n      }\n    }\n    // 如果找到匹配的函数,从数组中清除\n    if (postion !== -1) {\n      // 找到数组对应的位置,直接清除此回调\n      handler.splice(postion, 1);\n      // 如果清除后只有一个函数,那么取消数组,以函数形式保存\n      if (handler.length === 1) {\n        this._events.set(type, handler[0]);\n      }\n    } else {\n      return this;\n    }\n  }\n};\n\n")])])]),t("h2",{attrs:{id:"发现问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发现问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 发现问题")]),e._v(" "),t("blockquote",[t("p",[e._v("我们已经基本完成了Event最重要的几个方法,也完成了升级改造,可以说一个Event的骨架是被我们开发出来了,但是它仍然有不足和需要补充的地方.")])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("鲁棒性不足: 我们没有对参数进行充分的判断,没有完善的报错机制.")]),e._v(" "),t("li",[e._v("模拟不够充分: 除了removeAllListeners这些方法没有实现以外,例如监听时间后会触发newListener事件,我们也没有实现,另外最开始的监听者上限我们也没有利用到.")])])]),e._v(" "),t("blockquote",[t("p",[e._v("当然,这在面试中现场写一个Event已经是很够意思了,主要是体现出来对发布-订阅模式的理解,以及针对多个监听状况下的处理,不可能现场撸几百行写一个完整Event.")])]),e._v(" "),t("blockquote",[t("p",[e._v("索性"),t("a",{attrs:{href:"https://github.com/Gozala/events/blob/master/events.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("Event"),t("OutboundLink")],1),e._v("库帮我们实现了完整的特性,整个代码量有300多行,很适合阅读,你可以花十分钟的时间通读一下,见识一下完整的Event实现.")])])])},[],!1,null,null,null);n.default=s.exports}}]);