(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{174:function(t,e,n){"use strict";n.r(e);var a=n(0),o=Object(a.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook","aria-hidden":"true"}},[t._v("#")]),t._v(" Hook")]),t._v(" "),n("h2",{attrs:{id:"什么是-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-hook","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是 Hook?")]),t._v(" "),n("blockquote",[n("p",[t._v("Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。")])]),t._v(" "),n("h2",{attrs:{id:"usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate","aria-hidden":"true"}},[t._v("#")]),t._v(" useState")]),t._v(" "),n("blockquote",[n("p",[t._v("useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。\nconst [count, setCount] = useState(0);\nuseState 唯一的参数就是初始 state。")])]),t._v(" "),n("h2",{attrs:{id:"effect-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#effect-hook","aria-hidden":"true"}},[t._v("#")]),t._v(" Effect Hook")]),t._v(" "),n("blockquote",[n("p",[t._v("useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 相当于 componentDidMount 和 componentDidUpdate:\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n    return () => {\n      // 解绑回调\n    }\n  });\n\n  return (\n    <div>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")])])]),n("h2",{attrs:{id:"无需清除的-effect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#无需清除的-effect","aria-hidden":"true"}},[t._v("#")]),t._v(" 无需清除的 effect")]),t._v(" "),n("blockquote",[n("p",[t._v("useEffect 做了什么？ 通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。")])]),t._v(" "),n("blockquote",[n("p",[t._v("为什么在组件内部调用 useEffect？ 将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。")])]),t._v(" "),n("blockquote",[n("p",[t._v("useEffect 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）")])]),t._v(" "),n("h2",{attrs:{id:"需要清除的-effect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#需要清除的-effect","aria-hidden":"true"}},[t._v("#")]),t._v(" 需要清除的 effect")]),t._v(" "),n("blockquote",[n("p",[t._v("为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n  // ...\n}\n// Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。\n\n")])])]),n("h2",{attrs:{id:"通过跳过-effect-进行性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通过跳过-effect-进行性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 通过跳过 Effect 进行性能优化")]),t._v(" "),n("blockquote",[n("p",[t._v("你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可,对于有清除操作的 effect 同样适用")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 仅在 count 更改时更新\n")])])]),n("h2",{attrs:{id:"hook-使用规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook-使用规则","aria-hidden":"true"}},[t._v("#")]),t._v(" Hook 使用规则")]),t._v(" "),n("blockquote",[n("p",[t._v("Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：")])]),t._v(" "),n("blockquote",[n("ul",[n("li",[t._v("只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。")]),t._v(" "),n("li",[t._v("只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）")])])]),t._v(" "),n("h2",{attrs:{id:"自定义-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义-hook","aria-hidden":"true"}},[t._v("#")]),t._v(" 自定义 Hook")]),t._v(" "),n("blockquote",[n("p",[t._v("Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。")])]),t._v(" "),n("blockquote",[n("p",[t._v("自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 useSomething 的命名约定可以让我们的 linter 插件在使用 Hook 的代码中找到 bug。")])]),t._v(" "),n("h2",{attrs:{id:"eslint-插件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eslint-插件","aria-hidden":"true"}},[t._v("#")]),t._v(" ESLint 插件")]),t._v(" "),n("blockquote",[n("p",[t._v("Hook 使用规则\n我们发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来强制执行这两条规则。如果你想尝试一下，可以将此插件添加到你的项目中：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('npm install eslint-plugin-react-hooks --save-dev\n// 你的 ESLint 配置\n{\n  "plugins": [\n    // ...\n    "react-hooks"\n  ],\n  "rules": {\n    // ...\n    "react-hooks/rules-of-hooks": "error", // 检查 Hook 的规则\n    "react-hooks/exhaustive-deps": "warn" // 检查 effect 的依赖\n  }\n}\n')])])]),n("h2",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext","aria-hidden":"true"}},[t._v("#")]),t._v(" useContext")]),t._v(" "),n("blockquote",[n("p",[t._v("接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <MyContext.Provider> 的 value prop 决定。")])]),t._v(" "),n("blockquote",[n("p",[t._v("当组件上层最近的 <MyContext.Provider> 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。")])]),t._v(" "),n("blockquote",[n("p",[t._v("标准方式")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('import React from "react";\nimport ReactDOM from "react-dom";\n\n// Create a Context\nconst NumberContext = React.createContext();\n// It returns an object with 2 values:\n// { Provider, Consumer }\n\nfunction App() {\n  // Use the Provider to make a value available to all\n  // children and grandchildren\n  return (\n    <NumberContext.Provider value={42}>\n      <div>\n        <Display />\n      </div>\n    </NumberContext.Provider>\n  );\n}\n\nfunction Display() {\n  // Use the Consumer to grab the value from context\n  // Notice this component didn\'t get any props!\n  return (\n    <NumberContext.Consumer>\n      {value => <div>The answer is {value}.</div>}\n    </NumberContext.Consumer>\n  );\n}\n\nReactDOM.render(<App />, document.querySelector("#root"));\n')])])]),n("blockquote",[n("p",[t._v("hooks方式")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useState , createContext , useContext } from 'react';\n\nlet CountContext = createContext()\n\n<CountContext.Provider value={count}>\n    <Counter />\n</CountContext.Provider>\n\nfunction Counter(){\n    const count = useContext(CountContext)  //一句话就可以得到count\n    return (<h2>{count}</h2>)\n}\n\n")])])]),n("blockquote",[n("p",[t._v("hook嵌套")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import React, { useState , createContext , useContext } from 'react';\n\nlet CurrentUser = createContext()\nlet Notifications = createContext()\n\n<CurrentUser.Provider value={aaa}>\n  <Notifications.Provider value={bbb}>\n    <HeaderBar/>\n  </Notifications>\n</CurrentUser>\n\n\n\nfunction HeaderBar() {\n  const aaa = useContext(CurrentUser);\n  const bbb = useContext(Notifications);\n\n  return (\n    <header>\n      Welcome back, {aaa}!\n      You have {bbb} notifications.\n    </header>\n  );\n}\n")])])]),n("h2",{attrs:{id:"usereducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer","aria-hidden":"true"}},[t._v("#")]),t._v(" useReducer")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n    </>\n  );\n}\n")])])]),n("h2",{attrs:{id:"usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo","aria-hidden":"true"}},[t._v("#")]),t._v(" useMemo")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(">const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n返回一个 memoized 值。\n\n>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。\n\n>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。\n\n>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。\n")])])]),n("h2",{attrs:{id:"usecallback"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback","aria-hidden":"true"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),n("blockquote",[n("p",[t._v("useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。")])])])},[],!1,null,null,null);e.default=o.exports}}]);