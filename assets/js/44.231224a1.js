(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{173:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"suspense-lazy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#suspense-lazy","aria-hidden":"true"}},[t._v("#")]),t._v(" Suspense lazy")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// Suspense要解决的两个问题：代码分片；异步获取数据。\n// React.lazy， 这样就能实现代码的懒加载。 React.lazy 的参数是一个function, 返回的是一个promise. 这里返回的是一个import 函数,\n// 目前react 的渲染模式还是同步的， 那我现在画到clock 这里， 但是这clock 什么时候能下载完呢， 不知道。 假设你要花十分钟去下载， 那这十分钟你让react 去干啥， 总不能一直等你吧。 Suspens 就是来解决这个问题的， 你要画clock, 现在没有，那就会抛一个异常出来，我们之前说componentDidCatch 和 getDerivedStateFromProps, 这两个函数就是来抓子组件 或者 子子组件抛出的异常的。抓住这个异常，抓住之后干嘛呢， 还能干嘛呀， 忍着。下载资源的时候会抛出一个promise, 会有地方(这里是suspense)捕捉这个promise ,一看， 哎， 小老弟，你来啦，还是个promise, 然后就等这个promise resole\n// 到这， 我们说完了Suspense 的一半功能， 还有另一半： 异步获取数据。\n")])])]),s("h2",{attrs:{id:"exact-strict"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#exact-strict","aria-hidden":"true"}},[t._v("#")]),t._v(" exact strict")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// exact默认为false，如果为true时，需要和路由相同时才能匹配，但是如果有斜杠也是可以匹配上的。\n// strict默认为false，如果为true时，路由后面有斜杠而url中没有斜杠，是不匹配的\n")])])]),s("h1",{attrs:{id:"tsx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tsx","aria-hidden":"true"}},[t._v("#")]),t._v(" tsx")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// import React, {Suspense, lazy} from 'react'\nimport { Switch, RouterProps, Route } from 'react-router-dom';\n// Suspense要解决的两个问题：代码分片；异步获取数据。\n\ntsx 必须用这种引用模式 import * as React from \"react\";\n")])])])])},[],!1,null,null,null);e.default=r.exports}}]);