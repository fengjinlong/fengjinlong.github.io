(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{164:function(n,t,e){"use strict";e.r(t);var r=e(0),o=Object(r.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"仿函数式组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#仿函数式组件","aria-hidden":"true"}},[n._v("#")]),n._v(" 仿函数式组件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("目标： fun.f([1,2,3])  fun([1,2,3]).f() 效果相同\n\n单个方法\nvar fun = function (obj) {\n      console.log(this)\n      // 返回对象\n      if (!(this instanceof fun)) return new fun(obj);\n      // 缓存参数\n      this._wrapped = obj;\n    }\n    // 静态方法\n    // fun.f([1,2,3])\n    fun.f = function (arr) {\n      console.log(arr.reverse())\n    }\n    // 将静态方法挂在原型上\n    fun.mixin = function (obj) {\n      var func = fun.f\n      // 原型方法\n      fun.prototype.f = function () {\n        var ob = [this._wrapped];\n        ob.push(arguments)\n        func.apply(fun, ob)\n      }\n      return fun\n    }\n    // 调用后等到原型方法\n    fun.mixin(fun)\n\n    // 调用原型方法\n    fun([1,2,3]).f(function (arr) {\n      console.log(arr.reverse())\n    })\n\n    全部方法\n    var fun = function (obj) {\n      console.log(this)\n      // 返回对象\n      if (!(this instanceof fun)) return new fun(obj);\n      // 缓存参数\n      this._wrapped = obj;\n    }\n    fun.each = function (obj, callback) {\n      if (Array.isArray(obj)) {\n        for (const item of obj) {\n          callback && callback.call(_, item);\n        }\n      }\n    }\n    // 静态方法\n    // fun.f([1,2,3])\n    fun.f = function (arr) {\n      console.log(arr.reverse())\n    }\n    // 将静态方法挂在原型上\n    fun.mixin = function (obj) {\n      //混合全部静态方法到原型链共享属性上\n      fun.each(_.functions(obj), function (name) {\n        var func = fun[name] = obj[name]\n        fun.prototype[name] = function () {\n          var args = [this._wrapped]\n          args.push(arguments)\n          func.apply(fun, args)\n        }\n      })\n      return fun\n    }\n    // 调用后等到原型方法\n    fun.mixin(fun)\n\n    // 调用原型方法\n    fun([1,2,3]).f()\n")])])]),e("h2",{attrs:{id:"简易版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简易版本","aria-hidden":"true"}},[n._v("#")]),n._v(" 简易版本")]),n._v(" "),e("p",[n._v("// 一 map\nArray.prototype.myMap = function (callBack, content) {\nvar arr = this\nvar res = []\ncontent = content ? content : window\nfor (let i = 0; i < arr.length; i++) {\nlet ele = callBack.call(content, arr[i], i, arr)\nres.push(ele)\n}\nreturn res\n}")]),n._v(" "),e("p",[n._v("// 二 reduce\nArray.prototype.myReduce = function(callback) {\nvar arr = this;\nvar res; "),n._v('\nif(typeof(callback) !== "function")  throw new Error("not a function");\nif(arguments.length < 2 && arr.length === 0) throw new Error("empty array with no initial value");\nif(arguments.length < 2 && arr.length === 1) return arr[0];\nif(arguments.length > 1 && arr.length === 0) return arguments[1];\nres = arguments.length > 1? arguments[1] : arr.shift();\nfor(let i = 0; i < arr.length; i++) {\nres = callback(res, arr[i], i, arr);\n}\nreturn res;\n}')]),n._v(" "),e("p",[n._v("// map的reduce实现\nArray.prototype._myMap = function(callback, context) {\ncontext = context ? context : window;\nreturn this.reduce((accum, item, index, arr) =>\n[...accum, callback.call(context, item, index, arr)]\n, []);\n}")]),n._v(" "),e("h2",{attrs:{id:"三-instanceof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-instanceof","aria-hidden":"true"}},[n._v("#")]),n._v(" 三 instanceof")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * 判断left是不是right类型的对象\n * @param {*} left \n * @param {*} right \n * @return {Boolean}\n */\nfunction instanceof2(left, right) {\n    let prototype = right.prototype;\n  \n    // 沿着left的原型链, 看看是否有何prototype相等的节点\n    left = left.__proto__;\n    while(1) {\n      if(left === null || left === undefined) {\n        return false;\n      }\n      if(left === prototype) {\n        return true;\n      }\n      left = left.__proto__;\n    }\n  }\n  \n  const selfInstanceof = function (left, right) {\n    let proto = Object.getPrototypeOf(left)\n    while (1) {\n      if(left === null || left === undefined) {\n        return false;\n      }\n      if (proto === right.prototype) {\n        return true\n      }\n      proto = Object.getPrototyprOf(proto)\n    }\n  }\n")])])]),e("h2",{attrs:{id:"四-new绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-new绑定","aria-hidden":"true"}},[n._v("#")]),n._v(" 四 new绑定")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 1. 创建（或者说构造）一个新对象。\n// 2. 这个新对象会被执行[[Prototype]]连接。\n// 3. 这个新对象会绑定到函数调用的this。\n// 4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n\n\n// ### 手写一个new实现\nfunction create () {\n  // 创建一个新对象\n  var obj = new Object()\n  // 取出构造函数\n  var Con = [].shift.call(arguments)\n  // 新对象的原型指向构造函数\n  // obj.__proto__ = Con.prototype\n  // 由于性能问题，推荐使用\n  Object.setPrototypeOf(obj, Con.prototype);\n  // 绑定 this 实现继承，obj 可以访问到构造函数中的属性\n  var o = Con.apply(obj, arguments)\n  return o instanceof Object ? o : obj\n}\n\n\nfunction create() {\n\t// 1、获得构造函数，同时删除 arguments 中第一个参数\n    Con = [].shift.call(arguments);\n\t// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性\n    var obj = Object.create(Con.prototype);\n\t// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性\n    var ret = Con.apply(obj, arguments);\n\t// 4、优先返回构造函数返回的对象\n\treturn ret instanceof Object ? ret : obj;\n};\n\n// ## 使用这个手写的new\n\nfunction Person() {...}\n// 使用内置函数new\nvar person = new Person(...)\n// 使用手写的new，即create\nvar person = create(Person, ...)\n\n// ## 代码原理解析：\n\n// 1. 用new Object() 的方式新建了一个对象obj\n\n// 2. 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数\n\n// 3. 将 obj 的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性\n\n// 4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\n\n// 5. 返回 obj\n\n// ## new\nconst isComplexDataType = obj => (typeof obj === 'object || typeof obj === 'function') && obj !== null\nconst selfNew = function (fn, ...rest) {\n    let instance = Object.create(fn.prototype)\n    let res = fn.apply(instance, rest)\n    return isComplexDataType(res) ? res : instance\n}\n")])])]),e("h2",{attrs:{id:"四-请实现一个bind函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-请实现一个bind函数","aria-hidden":"true"}},[n._v("#")]),n._v(" 四 请实现一个bind函数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('Function.prototype.bind2 = function (context) {\n\n  if (typeof this !== "function") {\n    throw new Error("Function.prototype.bind - what is trying to be bound is not callable");\n  }\n\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  var fNOP = function () {};\n\n  var fBound = function () {\n      var bindArgs = Array.prototype.slice.call(arguments);\n      return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));\n  }\n\n  fNOP.prototype = this.prototype;\n  fBound.prototype = new fNOP();\n  return fBound;\n}\n')])])]),e("h2",{attrs:{id:"五-请实现一个-json-stringify-和-json-parse"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-请实现一个-json-stringify-和-json-parse","aria-hidden":"true"}},[n._v("#")]),n._v(" 五 请实现一个 JSON.stringify 和 JSON.parse ????????????????????")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Car (color) {\n    this.color = color\n}\nCar.prototype.run = function () {\n    console.log(this.color + 'id run')\n}\nvar Cruze = function (color) {\n    Car.call(this, color)\n}\nvar _prototype = Object.create(Car.prototype)\n_prototype.constructor = Cruze\nCruze.prototype = _prototype\nCruze.prototype.gogo = function () {\n    console.log('gogo')\n}\nvar result = new Cruze('red')\nconsole.log(result)\nvar result2 = new Car('blue')\nconsole.log(result2)\n")])])])])},[],!1,null,null,null);t.default=o.exports}}]);