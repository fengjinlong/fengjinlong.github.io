(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{158:function(t,e,a){"use strict";a.r(e);var o=a(0),r=Object(o.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块")]),t._v(" "),a("h2",{attrs:{id:"严格模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#严格模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 严格模式")]),t._v(" "),a("blockquote",[a("p",[t._v("变量必须声明后再使用")])]),t._v(" "),a("blockquote",[a("p",[t._v("函数的参数不能有同名属性，否则报错")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能使用with语句")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能对只读属性赋值，否则报错")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能使用前缀 0 表示八进制数，否则报错")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能删除不可删除的属性，否则报错")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能删除变量delete prop，会报错，只能删除属性delete global[prop]")])]),t._v(" "),a("blockquote",[a("p",[t._v("eval不会在它的外层作用域引入变量")])]),t._v(" "),a("blockquote",[a("p",[t._v("eval和arguments不能被重新赋值")])]),t._v(" "),a("blockquote",[a("p",[t._v("arguments不会自动反映函数参数的变化")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能使用arguments.callee")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能使用arguments.caller")])]),t._v(" "),a("blockquote",[a("p",[t._v("禁止this指向全局对象")])]),t._v(" "),a("blockquote",[a("p",[t._v("不能使用fn.caller和fn.arguments获取函数调用的堆栈")])]),t._v(" "),a("blockquote",[a("p",[t._v("增加了保留字（比如protected、static和interface）")])]),t._v(" "),a("h2",{attrs:{id:"模块功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块功能","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块功能")]),t._v(" "),a("blockquote",[a("p",[t._v("主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。")])]),t._v(" "),a("h2",{attrs:{id:"export"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#export","aria-hidden":"true"}},[t._v("#")]),t._v(" export")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// profile.js\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n\nexport的写法，除了像上面这样，还有另外一种。\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\nexport { firstName, lastName, year };\n\nexport function multiply(x, y) {\n  return x * y;\n};\n\n通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\nfunction v1() { ... }\nfunction v2() { ... }\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n")])])]),a("blockquote",[a("p",[t._v("export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n")])])]),a("blockquote",[a("p",[t._v("第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n")])])]),a("blockquote",[a("p",[t._v("function和class的输出，也必须遵守这样的写法。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n")])])]),a("blockquote",[a("p",[t._v("export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n上面代码输出变量foo，值为bar，500 毫秒之后变成baz。\n\n这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新\n")])])]),a("h2",{attrs:{id:"import-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import-命令","aria-hidden":"true"}},[t._v("#")]),t._v(" import 命令")]),t._v(" "),a("blockquote",[a("p",[t._v("大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// main.js\nimport { firstName, lastName, year } from './profile.js';\n")])])]),a("blockquote",[a("p",[t._v("如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import { lastName as surname } from './profile.js';\n")])])]),a("blockquote",[a("p",[t._v("import命令具有提升效果，会提升到整个模块的头部，首先执行。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("foo();\n\nimport { foo } from 'my_module';\n")])])]),a("blockquote",[a("p",[t._v("import语句会执行所加载的模块，因此可以有下面的写法。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import 'lodash';\n上面代码仅仅执行lodash模块，但是不输入任何值。\n\n如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。\n\nimport 'lodash';\nimport 'lodash';\n上面代码加载了两次lodash，但是只会执行一次。\n\nimport { foo } from 'my_module';\nimport { bar } from 'my_module';\n\n// 等同于\nimport { foo, bar } from 'my_module';\n上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。\n")])])]),a("h2",{attrs:{id:"模块的整体加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块的整体加载","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块的整体加载")]),t._v(" "),a("blockquote",[a("p",[t._v("除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n现在，加载这个模块。\n\n// main.js\n\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\n\nimport * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () {};\n")])])]),a("h2",{attrs:{id:"export-default-命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#export-default-命令","aria-hidden":"true"}},[t._v("#")]),t._v(" export default 命令")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// export-default.js\nexport default function () {\n  console.log('foo');\n}\n")])])]),a("blockquote",[a("p",[t._v("上面代码是一个模块文件export-default.js，它的默认输出是一个函数。")])]),t._v(" "),a("blockquote",[a("p",[t._v("其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// import-default.js\nimport customName from './export-default';\ncustomName(); /\n")])])]),a("blockquote",[a("p",[t._v("上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。")])]),t._v(" "),a("blockquote",[a("p",[t._v("export default命令用在非匿名函数前，也是可以的。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// export-default.js\nexport default function foo() {\n  console.log('foo');\n}\n\n// 或者写成\n\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n")])])]),a("blockquote",[a("p",[t._v("上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。")])]),t._v(" "),a("blockquote",[a("p",[t._v("对比")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 第一组\nexport default function crc32() { // 输出\n  // ...\n}\n\nimport crc32 from 'crc32'; // 输入\n\n// 第二组\nexport function crc32() { // 输出\n  // ...\n};\n\nimport {crc32} from 'crc32'; // 输入\n")])])]),a("blockquote",[a("p",[t._v("上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。")])]),t._v(" "),a("blockquote",[a("p",[t._v("export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。")])]),t._v(" "),a("blockquote",[a("p",[t._v("本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// modules.js\nfunction add(x, y) {\n  return x * y;\n}\nexport {add as default};\n// 等同于\n// export default add;\n\n// app.js\nimport { default as foo } from 'modules';\n// 等同于\n// import foo from 'modules';\n")])])]),a("blockquote",[a("p",[t._v("正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n")])])]),a("blockquote",[a("p",[t._v("上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。")])]),t._v(" "),a("blockquote",[a("p",[t._v("同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 正确\nexport default 42;\n\n// 报错\nexport 42;\n")])])]),a("blockquote",[a("p",[t._v("有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import _ from 'lodash';\n")])])]),a("blockquote",[a("p",[t._v("如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import _, { each, forEach } from 'lodash';\n")])])]),a("blockquote",[a("p",[t._v("对应上面代码的export语句如下。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default function (obj) {\n  // ···\n}\n\nexport function each(obj, iterator, context) {\n  // ···\n}\n\nexport { each as forEach };\n")])])]),a("blockquote",[a("p",[t._v("export default也可以用来输出类。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// MyClass.js\nexport default class { ... }\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n")])])]),a("h2",{attrs:{id:"import"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import","aria-hidden":"true"}},[t._v("#")]),t._v(" import()")]),t._v(" "),a("blockquote",[a("p",[t._v("前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 报错\nif (x === 2) {\n  import MyModual from './myModual';\n}\n")])])]),a("blockquote",[a("p",[t._v("上面代码中，引擎处理import语句是在"),a("strong",[t._v("编译时")]),t._v("，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，"),a("strong",[t._v("import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。\n因为require是运行时加载模块，import命令无法取代"),a("strong",[t._v("require的动态加载")]),t._v("功能。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const path = './' + fileName;\nconst myModual = require(path);\n")])])]),a("blockquote",[a("p",[t._v("上面的语句就是"),a("strong",[t._v("动态加载")]),t._v("，require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。")])]),t._v(" "),a("blockquote",[a("p",[t._v("因此，有一个提案，建议引入import()函数，完成动态加载。")])]),t._v(" "),a("blockquote",[a("p",[t._v("import()返回一个 Promise 对象。下面是一个例子。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const main = document.querySelector('main');\n\nimport(`./section-modules/${someVariable}.js`)\n  .then(module => {\n    module.loadPageInto(main);\n  })\n  .catch(err => {\n    main.textContent = err.message;\n  });\n")])])]),a("blockquote",[a("p",[t._v("import()类似于 Node 的require方法，区别主要是"),a("strong",[t._v("前者是异步加载，后者是同步加载")]),t._v("。")])]),t._v(" "),a("h2",{attrs:{id:"import-适用场合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import-适用场合","aria-hidden":"true"}},[t._v("#")]),t._v(" import()适用场合")]),t._v(" "),a("blockquote",[a("p",[t._v("+按需加载。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import()可以在需要的时候，再加载某个模块。\nbutton.addEventListener('click', event => {\n  import('./dialogBox.js')\n  .then(dialogBox => {\n    dialogBox.open();\n  })\n  .catch(error => {\n    /* Error handling */\n  })\n});\n上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。\n")])])]),a("blockquote",[a("p",[t._v("+条件加载")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import()可以放在if代码块，根据不同的情况，加载不同的模块。\n\nif (condition) {\n  import('moduleA').then(...);\n} else {\n  import('moduleB').then(...);\n}\n上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。\n")])])]),a("blockquote",[a("p",[t._v("+动态的模块路径")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import()允许模块路径动态生成。\n\nimport(f())\n.then(...);\n上面代码中，根据函数f的返回结果，加载不同的模块。\n")])])]),a("h2",{attrs:{id:"注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意点","aria-hidden":"true"}},[t._v("#")]),t._v(" 注意点")]),t._v(" "),a("blockquote",[a("p",[t._v("import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import('./myModule.js')\n.then(({export1, export2}) => {\n  // ...·\n});\n上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。\n")])])]),a("blockquote",[a("p",[t._v("如果模块有default输出接口，可以用参数直接获得。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import('./myModule.js')\n.then(myModule => {\n  console.log(myModule.default);\n});\n上面的代码也可以使用具名输入的形式。\n\nimport('./myModule.js')\n.then(({default: theDefault}) => {\n  console.log(theDefault);\n});\n")])])]),a("blockquote",[a("p",[t._v("如果想同时加载多个模块，可以采用下面的写法。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Promise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) => {\n   ···\n});\n")])])]),a("blockquote",[a("p",[t._v("import()也可以用在 async 函数之中。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("async function main() {\n  const myModule = await import('./myModule.js');\n  const {export1, export2} = await import('./myModule.js');\n  const [module1, module2, module3] =\n    await Promise.all([\n      import('./module1.js'),\n      import('./module2.js'),\n      import('./module3.js'),\n    ]);\n}\nmain();\n")])])])])},[],!1,null,null,null);e.default=r.exports}}]);